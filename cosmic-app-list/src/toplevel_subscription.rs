//! # DBus interface proxy for: `org.freedesktop.UPower.KbdBacklight`
//!
//! This code was generated by `zbus-xmlgen` `2.0.1` from DBus introspection data.
//! Source: `Interface '/org/freedesktop/UPower/KbdBacklight' from service 'org.freedesktop.UPower' on system bus`.
use cctk::sctk::reexports::client::protocol::wl_seat::WlSeat;
use cctk::toplevel_info::ToplevelInfo;
use cosmic::iced;
use cosmic::iced::subscription;
use cosmic_protocols::toplevel_info::v1::client::zcosmic_toplevel_handle_v1::ZcosmicToplevelHandleV1;
use futures::{
    channel::mpsc::{unbounded, UnboundedReceiver},
    StreamExt,
};
use std::{fmt::Debug, hash::Hash, thread::JoinHandle};

use crate::toplevel_handler::toplevel_handler;

pub fn toplevel_subscription<I: 'static + Hash + Copy + Send + Sync + Debug>(
    id: I,
) -> iced::Subscription<(I, ToplevelUpdate)> {
    subscription::unfold(id, State::Ready, move |state| start_listening(id, state))
}

pub enum State {
    Ready,
    Waiting(
        UnboundedReceiver<ToplevelUpdate>,
        calloop::channel::Sender<ToplevelRequest>,
        JoinHandle<()>,
    ),
    Finished,
}

async fn start_listening<I: Copy>(id: I, mut state: State) -> ((I, ToplevelUpdate), State) {
    loop {
        let (update, new_state) = match state {
            State::Ready => {
                let (calloop_tx, calloop_rx) = calloop::channel::channel();
                let (toplevel_tx, toplevel_rx) = unbounded();
                let handle = std::thread::spawn(move || {
                    toplevel_handler(toplevel_tx, calloop_rx);
                });
                (
                    Some((id, ToplevelUpdate::Init(calloop_tx.clone()))),
                    State::Waiting(toplevel_rx, calloop_tx, handle),
                )
            }
            State::Waiting(mut rx, tx, handle) => {
                if handle.is_finished() {
                    return ((id, ToplevelUpdate::Finished), State::Finished);
                }
                match rx.next().await {
                    Some(u) => (Some((id, u)), State::Waiting(rx, tx, handle)),
                    None => {
                        let _ = tx.send(ToplevelRequest::Exit);
                        (Some((id, ToplevelUpdate::Finished)), State::Finished)
                    }
                }
            }
            State::Finished => iced::futures::future::pending().await,
        };

        if let Some(update) = update {
            return (update, new_state);
        } else {
            state = new_state;
        }
    }
}

#[derive(Clone, Debug)]
pub enum ToplevelUpdate {
    Finished,
    AddToplevel(ZcosmicToplevelHandleV1, ToplevelInfo),
    UpdateToplevel(ZcosmicToplevelHandleV1, ToplevelInfo),
    RemoveToplevel(ZcosmicToplevelHandleV1),
    Init(calloop::channel::Sender<ToplevelRequest>),
}

#[derive(Debug, Clone)]
pub enum ToplevelRequest {
    Activate(ZcosmicToplevelHandleV1, WlSeat),
    Quit(ZcosmicToplevelHandleV1),
    Exit,
}
